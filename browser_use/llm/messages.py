"""
This implementation is based on the OpenAI types, while removing all the parts that are not needed for Browser Use.
"""

# region - Content parts
from typing import Iterable, Literal, Union

from openai import BaseModel


class ContentPartTextParam(BaseModel):
	text: str
	type: Literal['text'] = 'text'


class ContentPartRefusalParam(BaseModel):
	refusal: str
	type: Literal['refusal'] = 'refusal'


SupportedImageMediaType = Literal['image/jpeg', 'image/png', 'image/gif', 'image/webp']


class ImageURL(BaseModel):
	url: str
	"""Either a URL of the image or the base64 encoded image data."""
	detail: Literal['auto', 'low', 'high'] = 'auto'
	"""Specifies the detail level of the image.

    Learn more in the
    [Vision guide](https://platform.openai.com/docs/guides/vision#low-or-high-fidelity-image-understanding).
    """
	# needed for Anthropic
	media_type: SupportedImageMediaType = 'image/png'


class ContentPartImageParam(BaseModel):
	image_url: ImageURL
	type: Literal['image_url'] = 'image_url'


class Function(BaseModel):
	arguments: str
	"""
    The arguments to call the function with, as generated by the model in JSON
    format. Note that the model does not always generate valid JSON, and may
    hallucinate parameters not defined by your function schema. Validate the
    arguments in your code before calling your function.
    """
	name: str
	"""The name of the function to call."""


class ToolCall(BaseModel):
	id: str
	"""The ID of the tool call."""
	function: Function
	"""The function that the model called."""
	type: Literal['function'] = 'function'
	"""The type of the tool. Currently, only `function` is supported."""


# endregion


# region - Message types


class UserMessage(BaseModel):
	role: Literal['user'] = 'user'
	"""The role of the messages author, in this case `user`."""

	content: Union[str, Iterable[Union[ContentPartTextParam, ContentPartImageParam]]]
	"""The contents of the user message."""

	name: str | None = None
	"""An optional name for the participant.

    Provides the model information to differentiate between participants of the same
    role.
    """

	@property
	def text(self) -> str:
		if isinstance(self.content, str):
			return self.content
		elif isinstance(self.content, Iterable):
			return '\n'.join([part.text for part in self.content if part.type == 'text'])
		else:
			return ''


class SystemMessage(BaseModel):
	role: Literal['system'] = 'system'
	"""The role of the messages author, in this case `system`."""

	content: Union[str, Iterable[ContentPartTextParam]]
	"""The contents of the system message."""

	name: str | None = None

	@property
	def text(self) -> str:
		if isinstance(self.content, str):
			return self.content
		elif isinstance(self.content, Iterable):
			return '\n'.join([part.text for part in self.content if part.type == 'text'])
		else:
			return ''


class AssistantMessage(BaseModel):
	role: Literal['assistant'] = 'assistant'
	"""The role of the messages author, in this case `assistant`."""

	content: Union[str, Iterable[Union[ContentPartTextParam, ContentPartRefusalParam]], None]
	"""The contents of the assistant message."""

	name: str | None = None

	refusal: str | None = None
	"""The refusal message by the assistant."""

	tool_calls: Iterable[ToolCall] = []
	"""The tool calls generated by the model, such as function calls."""

	@property
	def text(self) -> str:
		if isinstance(self.content, str):
			return self.content
		elif isinstance(self.content, Iterable):
			text = ''
			for part in self.content:
				if part.type == 'text':
					text += part.text
				elif part.type == 'refusal':
					text += f'[Refusal] {part.refusal}'
			return text
		else:
			return ''


BaseMessage = Union[UserMessage, SystemMessage, AssistantMessage]

# endregion
